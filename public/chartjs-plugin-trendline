/**
 * Minified by jsDelivr using Terser v5.39.0.
 * Original file: /npm/chartjs-plugin-trendline@2.1.7/src/chartjs-plugin-trendline.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
/*!
 * chartjs-plugin-trendline.js
 * Version: 2.1.7
 *
 * Copyright 2025 Marcus Alsterfjord
 * Released under the MIT license
 * https://github.com/Makanz/chartjs-plugin-trendline/blob/master/README.md
 *
 * Modified by @vesal: accept xy-data from scatter,
 * Modified by @Megaemce: add label and basic legend to trendline, add JSDoc,
 */
const pluginTrendlineLinear={id:"chartjs-plugin-trendline",afterDatasetsDraw:e=>{const t=e.ctx,{xScale:i,yScale:n}=getScales(e);e.data.datasets.forEach(((l,a)=>{const s=l.alwaysShowTrendline||e.isDatasetVisible(a);if(l.trendlineLinear&&s&&l.data.length>1){const s=e.getDatasetMeta(a);addFitter(s,t,l,i,n)}})),t.setLineDash([])},beforeInit:e=>{e.data.datasets.forEach((t=>{if(t.trendlineLinear&&t.trendlineLinear.label){const i=t.trendlineLinear.label,n=e.legend.options.labels.generateLabels;e.legend.options.labels.generateLabels=function(e){const l=n(e),a=t.trendlineLinear.legend;return a&&!1!==a.display&&l.push({text:a.text||i+" (Trendline)",strokeStyle:a.color||t.borderColor||"rgba(169,169,169, .6)",fillStyle:a.fillStyle||"transparent",lineCap:a.lineCap||"butt",lineDash:a.lineDash||[],lineWidth:a.width||1}),l}}}))}},getScales=e=>{let t,i;for(const n of Object.values(e.scales))if(n.isHorizontal()?t=n:i=n,t&&i)break;return{xScale:t,yScale:i}},addFitter=(e,t,i,n,l)=>{const a=i.yAxisID||"y",s=e.controller.chart.scales[a]||l,r=i.borderColor||"rgba(169,169,169, .6)",{colorMin:o=r,colorMax:d=r,width:c=i.borderWidth||3,lineStyle:h="solid",fillColor:x=!1}=i.trendlineLinear||{},{color:u=r,text:y="Trendline",display:f=!0,displayValue:m=!0,offset:p=10,percentage:w=!1}=i.trendlineLinear.label||{},{family:g="'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",size:L=12}=i.trendlineLinear.label?.font||{},b=e.controller.chart.options,F="object"==typeof b.parsing?b.parsing:void 0,T=i.trendlineLinear?.xAxisKey||F?.xAxisKey||"x",S=i.trendlineLinear?.yAxisKey||F?.yAxisKey||"y";let C=new LineFitter,D=i.data.findIndex((e=>null!=e)),v=(i.data.length,"object"==typeof i.data[D]);i.data.forEach(((e,t)=>{if(null!=e)if(["time","timeseries"].includes(n.options.type)){let i=null!=e[T]?e[T]:e.t;void 0!==i?C.add(new Date(i).getTime(),e[S]):C.add(t,e)}else v?isNaN(e.x)||isNaN(e.y)?isNaN(e.x)?isNaN(e.y)||C.add(t,e.y):C.add(t,e.x):C.add(e.x,e.y):C.add(t,e)}));let N,P,A=n.getPixelForValue(C.minx),M=s.getPixelForValue(C.f(C.minx));if(i.trendlineLinear.projection&&C.scale()<0){let e=C.fo();e<C.minx&&(e=C.maxx),N=n.getPixelForValue(e),P=s.getPixelForValue(C.f(e))}else N=n.getPixelForValue(C.maxx),P=s.getPixelForValue(C.f(C.maxx));const V=e.controller.chart.chartArea.bottom,k=e.controller.chart.width;if(isFinite(A)&&isFinite(M)&&isFinite(N)&&isFinite(P)){adjustLineForOverflow({x1:A,y1:M,x2:N,y2:P,drawBottom:V,chartWidth:k}),t.lineWidth=c,setLineStyle(t,h),drawTrendline({ctx:t,x1:A,y1:M,x2:N,y2:P,colorMin:o,colorMax:d}),x&&fillBelowTrendline(t,A,M,N,P,V,x);const e=Math.atan2(P-M,N-A),n=(M-P)/(N-A);if(i.trendlineLinear.label&&!1!==f){const i=m?`${y} (Slope: ${w?(100*n).toFixed(2)+"%":n.toFixed(2)})`:y;addTrendlineLabel(t,i,A,M,N,P,e,u,g,L,p)}}},addTrendlineLabel=(e,t,i,n,l,a,s,r,o,d,c)=>{e.font=`${d}px ${o}`,e.fillStyle=r;const h=e.measureText(t).width,x=(i+l)/2,u=(n+a)/2;e.save(),e.translate(x,u),e.rotate(s);const y=-h/2,f=c;e.fillText(t,y,f),e.restore()},adjustLineForOverflow=({x1:e,y1:t,x2:i,y2:n,drawBottom:l,chartWidth:a})=>{if(t>l){let e=t-l,i=t-n;t=l}else if(n>l){let e=n-l,s=n-t;n=l,i=a-(i-(a-a*(e/s)))}},setLineStyle=(e,t)=>{switch(t){case"dotted":e.setLineDash([2,2]);break;case"dashed":e.setLineDash([8,3]);break;case"dashdot":e.setLineDash([8,3,2,3]);break;default:e.setLineDash([])}},drawTrendline=({ctx:e,x1:t,y1:i,x2:n,y2:l,colorMin:a,colorMax:s})=>{if(isFinite(t)&&isFinite(i)&&isFinite(n)&&isFinite(l)){e.beginPath(),e.moveTo(t,i),e.lineTo(n,l);try{let r=e.createLinearGradient(t,i,n,l);r.addColorStop(0,a),r.addColorStop(1,s),e.strokeStyle=r}catch(t){console.warn("Gradient creation failed, using solid color:",t),e.strokeStyle=a}e.stroke(),e.closePath()}else console.warn("Cannot draw trendline: coordinates contain non-finite values",{x1:t,y1:i,x2:n,y2:l})},fillBelowTrendline=(e,t,i,n,l,a,s)=>{isFinite(t)&&isFinite(i)&&isFinite(n)&&isFinite(l)&&isFinite(a)?(e.beginPath(),e.moveTo(t,i),e.lineTo(n,l),e.lineTo(n,a),e.lineTo(t,a),e.lineTo(t,i),e.closePath(),e.fillStyle=s,e.fill()):console.warn("Cannot fill below trendline: coordinates contain non-finite values",{x1:t,y1:i,x2:n,y2:l,drawBottom:a})};class LineFitter{constructor(){this.count=0,this.sumx=0,this.sumy=0,this.sumx2=0,this.sumxy=0,this.minx=Number.MAX_VALUE,this.maxx=Number.MIN_VALUE}add(e,t){this.sumx+=e,this.sumy+=t,this.sumx2+=e*e,this.sumxy+=e*t,e<this.minx&&(this.minx=e),e>this.maxx&&(this.maxx=e),this.count++}slope(){const e=this.count*this.sumx2-this.sumx*this.sumx;return(this.count*this.sumxy-this.sumx*this.sumy)/e}intercept(){return(this.sumy-this.slope()*this.sumx)/this.count}f(e){return this.slope()*e+this.intercept()}fo(){return-this.intercept()/this.slope()}scale(){return this.slope()}}"undefined"!=typeof window&&window.Chart&&(window.Chart.hasOwnProperty("register")?window.Chart.register(pluginTrendlineLinear):window.Chart.plugins.register(pluginTrendlineLinear));try{module.exports=exports=pluginTrendlineLinear}catch(e){}
//# sourceMappingURL=/sm/94ab976d0cba4d25db043c266b13ad7f90c5d514d7c64f33cc964dbbe50b0447.map